# Huawei-Code-Craft
2019华为软件精英挑战赛

昨天听说了华为的这个比赛，举例初赛结束还有三天，O(∩_∩)O哈哈~

并没有打算参入比赛，但是想看一下比赛的内容，于是我 **报名了 ** :(



在此稍作分析就当做比赛吧：

- 根据数据分析，提供的数据都是足够的，如果去除任何车辆之间的相互约束，那么其实就是最短路径算法(你反对，明明每条路限速还不一样)，那我换个说法：**最短时间算法** ，路程除以速度 [$v=min(V_{road},V_{car})​$ ] 不就是时间吗，然后就是一样了。

- 但是即使如上所说，节点和边很多了之后我也觉得挺耗时的。。。。。 所以我觉得要是能够提供各个节点的坐标就好了。就像我们平时打开高德地图里面也有推荐路线一样，我们可以知道起点和终点的坐标，然后给我们指出了一条大致的方位，然后我们就可以有倾向性搜索。然鹅没有，那算了，就先假设我们每次都求出全局最短时间路径

- 那么现在需要考虑车辆之间的约束了，主要就是一个问题：避免拥堵，还要解决一个bug：避免死锁。

- 回去看数据，我发现车辆的数量远远大于节点和边的数量，所以缓解了拥堵也就赢得了比赛

- 我们第一步需要做的就是一个解释器，能够根据路径给出车辆的运行时间。官方的做法就是按照时间tick来一步步模拟。这给了我们一个很好的提示。 显然车辆这么多，我们如果一开始就规划好所有车辆的路径，结果是十分差的(这类方法比如诸多的仿生算法)，这是由于中间很容易产生拥堵。 最好的方法应该是 **随机应变** 。

- 不仅仅是这么一个问题，我们想象一下现实的行车，我们这一刻根本很难预知下一刻有人就要从某个地点出行，既然没法预测未来的车流，那么提前考虑未来的车流显得没有依据(即使这可能带来更好的结果)。 

- 编程过程中需要考虑如何存储车流信息，这是成功的一大关键，我的想法很简单，每一个车辆都有一个坐标 (road_id,  distance, direction) 其中distance表示该车在这条道路上已经行驶的长度。 但是这还是欠缺了点，我们需要知道车辆前后的信息，我觉得这个信息应该挂载到道路上。

  ```C++
  class Road
  {
  	bool SingleDir； //是否单向行驶
      int Vmax;
          
  	int id;
      int channel;
      int length;
      
      Vector[] FCars; //向前行驶的car列表,按照通道分
      Vector[] BCars; //反向行驶的Car列表，按照通道分
  }
  ```

  每次我们只需要增量更新车辆的信息，进来一辆车只需要 push到列表的尾部，出去就pop开始的车辆。

- 我们说回随机应变，我们聚焦于一个节点，只考虑进来的车流。 首先能够确定最终位置的车显然不在重点考虑范围，余下的车我们根据车的限速拍个序。因为慢车可以影响快车，快车不会影响慢车。 依次根据最短时间算法找到每一辆车的最佳路径，用来确定目前车应该左转、前行还是右转（并不是用来确定以后所有的路径）。 但是该如何考虑其余车辆的影响呢？？？ 简单，我们只需要根据目前的车流分布分别更新每条Road的速度上限。

  ```python
  //以road 举例
  cars = road.getallcars(direction)
  VLimit=road.Vmax
  for car in cars:
  	VLimitByCar = road.length/(car.remainLength*1.0/car.speed) //暂时作为double处理
  	VLimit=min(VLimit,VLimitByCar)
  road.VLimit=Vlimit
  //那么在以任何一辆车考量， 这条路的行驶时间为
  Tvirtual=road.length/min(road.VLimit,car.VLimit)
  ```

  需要注意的是，我们按照车辆速度从小到大开始规划的，所以还要结合官方的解释器顺序，后面考虑的车辆如果优先级高于前面考虑的车辆，那么不受影响(因为其更快)。 如果后面考虑的车辆优先级较低，那么需要将前面考虑的车辆也加入考量，在前面车辆行进道路上速度就被限制了。方法同上，只是`road.getallcars` 函数中就出现了之前的车辆。

- 那么死锁怎么办？？？？ 当然是设置一个禁忌表，当模拟运行出现死锁的时候，选择“前排的观众”(每个车道优先考虑的车辆) 中最出色的一个(达到终点估计所需要时间最短的)。 禁止这车走之前的方向，换一个其余的方向，不行的话依次选择其余造成死锁的车辆更换路线， 还是用最短时间算法。如果问题解决那么按照新的规划重新调度这个时间点，检验可行性。

> 说了这么久，不知道再表达什么。。。。好吧，我们来看一下整个过程

```pyhton
while(当还有车辆没有到终点)：
	timetick+=1
	保护现场，将现在的状态备份Scopy=S.copy()
	while (还有车辆状态没确定)：
        for node in nodes:
            for road in node.in_roads:
                将等待调解的车辆选出来（能够确定最终位置的就就直接扔到终点)
            按照速度上限排序（慢的优先）
            依次按照最短时间算法确定车辆的路口行为（左转，前行，右转）
			for road in node.in_roads:
				按照规则进行调度安排
		if 出现死锁：
			依次挑选造成死锁的预计最快到达终点的车辆变道
			只要能够消除死锁就结束
			S=Scopy
输出结果
```

只是粗略看一下，随意写一下，可能问题特别多，那反正主要的思想就是按照每一个时刻分别确定每条道路的限速，然后结合车辆的限速得到对应车辆对应道路的限速，然后可以得到时间。